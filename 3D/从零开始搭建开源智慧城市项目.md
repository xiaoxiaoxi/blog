# 从零开始搭建开源智慧城市项目（一）初始化场景

[![img](https://p9-passport.byteacctimg.com/img/user-avatar/5894006e106aef734beccc90facfcfe1~300x300.image)](https://juejin.cn/user/3703616627815518)

[Lixc ![lv-2](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg)](https://juejin.cn/user/3703616627815518)

2021年12月17日 16:32 · 阅读 918

关注

## 前言

本篇文章是从零开始仿写一个智慧城市系列文章的第一篇，这一篇主要实现一下项目的初始化，添加一下`Three`场景的三大组件：场景（`scene`）、相机（`camera`）和渲染器（`renderer`），加一个控制器可以通关鼠标控制移动场景，把模型数据加载到场景里面。

## 初始化项目

初始化项目 然后创建一个`scens`的vue文件 创建一个`div`

```javascript
<template>
  <div id="scene"></div>
</template>
复制代码
```

然后引入three模块 ,然后引入这次需要的几个文件.

```javascript
import * as THREE from "three";//引入three模块
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";//控制器模块
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";//gltf模型加载模块
复制代码
```

## 初始化Three三要素

1. 场景： `three`中创建场景只需要`new`一个`THREE.Scene`就行了

```javascript
      scene = new THREE.Scene();
复制代码
```

1. 相机： 相机在`three`中分成透视相机和正投影相机 这里用的是透视相机`PerspectiveCamera`

```javascript
      const width = window.innerWidth; // 窗口宽度
      const height = window.innerHeight; // 窗口高度
      /** 透视投影相机对象 */
      camera = new THREE.PerspectiveCamera(60, width / height, 1, 100000);
      camera.position.set(6000, 9000, 6000); // 树上面观察
      // camera.position.set(200, 30, 200); //树下面观察
      camera.lookAt(this.scene.position); // 设置相机方向(指向的场景对象)
复制代码
```

1. 渲染器： 渲染器决定了渲染的结果应该画在元素的什么元素上面，这里采用的是`WebGLRenderer`

```javascript
      const container = document.getElementById("scene");//或者Dom元素，前面需要创建一个id为scene的div。
      renderer = new THREE.WebGLRenderer({ alpha: true });//新建一个WebGLRenderer
      renderer.setSize(container.clientWidth, container.clientHeight); // 设置渲染区域尺寸
      container.appendChild(renderer.domElement); // body元素中插入canvas对象
复制代码
```

## 加载场景控制器并导入模型，添加光照

1. 模型控制器： 只需要创建一个`OrbitControls`并且把相机和渲染器中绑定的`Dom`元素传进去就行

```javascript
      controls = new OrbitControls(camera, renderer.domElement);
复制代码
```

1. 导入模型： 导入模型需要实例化一个`GLTFLoader`,然后调用`lod`方法，把模型地址加进去，然后把数据加载到scene中。

```javascript
const loader = new GLTFLoader();
     loader.load("shanghai.gltf", (gltf) => {
       scene.add(gltf.scene);
     });
复制代码
      controls = new OrbitControls(camera, renderer.domElement);
复制代码
```

3.加载光照： 现在模型已经能显示在场景里面了但是没有光照 现在需要加一下光照

```javascript
       //创建点光源和环境光源
        const point = new THREE.PointLight(0xffffff);
        point.position.set(6000, 9000, 6000); // 点光源位置
        scene.add(point); // 点光源添加到场景中
        // 环境光
        const ambient = new THREE.AmbientLight(0x888888);
        scene.add(ambient);
复制代码
```

效果图

![SDGIF_Rusult_1.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fe424beb8044bdca336f648a2193775~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

## 上完整代码

```js
<template>
  <div id="scene"></div>
</template>
<script>
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
let scene; //场景
let camera; //相机
let renderer; //创建渲染器
// eslint-disable-next-line no-unused-vars
let controls; //控制器
export default {
  mounted() {
    this.init();
    this.createControls();
    this.render();
      this.addGLTF();
  },
  methods: {
    init() {
      //创建场景
      scene = new THREE.Scene();
      /**
       * 透视投影相机设置
       */
      const width = window.innerWidth; // 窗口宽度
      const height = window.innerHeight; // 窗口高度

      /** 透视投影相机对象 */
      camera = new THREE.PerspectiveCamera(60, width / height, 1, 100000);
      camera.position.set(6000, 9000, 6000); // 树上面观察
      camera.lookAt(scene.position); // 设置相机方向(指向的场景对象)
      // 创建渲染器对象
      const container = document.getElementById("scene");
      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight); // 设置渲染区域尺寸
      container.appendChild(renderer.domElement); // body元素中插入canvas对象

        //创建点光源和环境光源
        const point = new THREE.PointLight(0xffffff);
        point.position.set(6000, 9000, 6000); // 点光源位置
        scene.add(point); // 点光源添加到场景中
        // 环境光
        const ambient = new THREE.AmbientLight(0x888888);
        scene.add(ambient);
    },
    createControls() {
      controls = new OrbitControls(camera, renderer.domElement);
    },
    render() {
      renderer.render(scene, camera);
      requestAnimationFrame(this.render); // 请求再次执行渲染函数render
    },
    addGLTF() {
      const loader = new GLTFLoader();
      loader.load("shanghai.gltf", (gltf) => {
        scene.add(gltf.scene);
      });
    },
  },
};
</script>
<style scoped>
html,
body,
#scene {
  width: 100%;
  height: 100vh;
  z-index: 2;
  position: absolute;
  top: 0%;
}
</style>

复制代码
```

项目地址：[github.com/lixiaochjaj…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flixiaochjajo%2FSmartCity-Three)

## 最后

这是第一篇创建场景，接下几篇我会介绍添加自定义材质，后处理实现模型材质替换，辉光效果，流动线，扫描线，扩散效果等使其看起来炫酷一些，并争取通过多种方式实现以上效果，添加天空盒并解决天空盒和后处理冲突问题，还有什么比较炫酷的效果欢迎大家提意见。



# 从零开始搭建开源智慧城市项目（二）模型线框和物理材质

[![img](https://p9-passport.byteacctimg.com/img/user-avatar/5894006e106aef734beccc90facfcfe1~300x300.image)](https://juejin.cn/user/3703616627815518)

[Lixc ![lv-2](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg)](https://juejin.cn/user/3703616627815518)

2021年12月18日 18:53 · 阅读 399

关注

## 前言

上一章已经通过`GLTFLoader`把模型数据加载到场景，接下来我们对这些数据进行进一步处理。首先是把模型分类，整个模型可以分为三类，建筑（`CITY_UNTRIANGULATED`），道路（`ROADS`），地面（`other`）,对不同的数据分别添加不同的材质。

## 模型的线框添加

模型材质分为两个部分，第一部分是模型的线框材质，第二部分是模型的面材质，首先来说线框材质

1. 线框材质：通过`Three`的`EdgesGeometry`可以把生成模型的线框数据，用LineBasicMaterial生成线框的模型材质，然后用`LineSegments`把这两个数据组合到一起，即可生产线框模型对象。

```javascript
              // 拿到模型线框的Geometry,其中child.geometry是模型子对象的节点数据
              const edges = new THREE.EdgesGeometry(child.geometry, 1);
              //设置模型的材质
              const lineMaterial = new THREE.LineBasicMaterial({
                // 线的颜色
                color: "rgba(38,133,254)",
              });
              //把数据组合起来
              const lineS = new THREE.LineSegments(edges, lineMaterial);
              //设置数据的位置
              lineS.position.set(
                child.position.x,
                child.position.y,
                child.position.z
              );
              //添加到场景
              scene.add(lineS);
复制代码
```

效果图: ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ba1b98af4c4441bcb161240d6dea2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?) 2. 模型面材质：这里模型面材质选择的是`Three`的物理材质`MeshPhysicalMaterial`类，这个类可以模拟玻璃的质感.

```javascript
              // 模型面材质
             const material = new THREE.MeshPhysicalMaterial({
                //颜色为
                color: "rgb(50,170,255)",
                //金属度
                metalness: 0.5,
                //粗糙度
                roughness: 0.1,
                //透明度
                transmission: 0.9,
                //模型是否透明
                transparent: true,
              });
              //生成模型对象
              const mesh = new THREE.Mesh(child.geometry, material);
              //添加到场景
              scene.add(mesh);
复制代码
```

效果图：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83bc289926e9404eae86950a912f4694~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

## 地面和道路材质设置

道路和地面选择的是基本材质类`MeshBasicMaterial`

```javascript
             //道路
              const material = new THREE.MeshBasicMaterial({
                color: "rgb(41,46,76)",
              });
              const mesh = new THREE.Mesh(child.geometry, material);
              scene.add(mesh);
              //地面
              const material = new THREE.MeshBasicMaterial({
                color: "#040912",
              });
              const mesh = new THREE.Mesh(child.geometry, material);
              scene.add(mesh);

复制代码
```

效果图： ![GIF 2021-12-18 18-10-30.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55c0ab5452f34965b8a8d5fbec3c0fa4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

## 完整代码

```javascript
 addGLTF() {
      const loader = new GLTFLoader();
      loader.load("shanghai.gltf", (gltf) => {
        gltf.scene.traverse((child) => {
          // 设置线框材质

          if (child.isMesh) {
            //这个判断模型是楼房还是其他  加载不同的材质
            if (["CITY_UNTRIANGULATED"].includes(child.name)) {
              // 拿到模型线框的Geometry
              const edges = new THREE.EdgesGeometry(child.geometry, 1);
              //设置模型的材质
              const lineMaterial = new THREE.LineBasicMaterial({
                // 线的颜色
                color: "rgba(38,133,254)",
              });
              //把数据组合起来
              const lineS = new THREE.LineSegments(edges, lineMaterial);
              //设置数据的位置
              lineS.position.set(
                child.position.x,
                child.position.y,
                child.position.z
              );
              //添加到场景
              scene.add(lineS);
              lineS.rotateX(-Math.PI / 2);
              // 模型面材质
              const material = new THREE.MeshPhysicalMaterial({
                //颜色为
                color: "rgb(50,170,255)",
                //金属度
                metalness: 0.5,
                //粗糙度
                roughness: 0.1,
                //透明度
                transmission: 0.9,
                //模型是否透明
                transparent: true,
              });
              //生成模型对象
              const mesh = new THREE.Mesh(child.geometry, material);
              //添加到场景
              scene.add(mesh);
              mesh.position.set(
                child.position.x,
                child.position.y,
                child.position.z
              );

              mesh.rotateX(-Math.PI / 2);
            } else if (["ROADS"].includes(child.name)) {
              //道路
              const material = new THREE.MeshBasicMaterial({
                color: "rgb(41,46,76)",
           
              });
              const mesh = new THREE.Mesh(child.geometry, material);
              mesh.rotateX(-Math.PI / 2);
              mesh.position.set(
                child.position.x,
                child.position.y,
                child.position.z
              );
              scene.add(mesh);
            } else {
              //地面
              const material = new THREE.MeshBasicMaterial({
                color: "#040912",
              });
              const mesh = new THREE.Mesh(child.geometry, material);
              scene.add(mesh);
              mesh.rotateX(-Math.PI / 2);
              mesh.position.set(
                child.position.x,
                child.position.y,
                child.position.z
              );
          
            }
          }
          // 设置线框材质
        });
      });
    },
复制代码
```

项目地址: [github.com/lixiaochjaj…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flixiaochjajo%2FSmartCity-Three)

# 从零开始搭建开源智慧城市项目（三）上升线效果

[![img](https://p9-passport.byteacctimg.com/img/user-avatar/5894006e106aef734beccc90facfcfe1~300x300.image)](https://juejin.cn/user/3703616627815518)

[Lixc ![lv-2](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg)](https://juejin.cn/user/3703616627815518)

2021年12月20日 17:18 · 阅读 543

关注

## 前言

上一节实现了添加建筑物线框，模型外墙和道路地面材质添加。这一节准备通过简单的`shader`实现上升线效果。

## 思路

简单的说一下思路，通过获取模型顶点坐标所在的高度Z来进行筛选，高度再某一区间内设置成上升线的颜色，其余高度颜色正常，把高度不断上升来让这根上升线不断上升，到一定高度后重置。

## ShaderMaterial的组成

实现主要通关`Three`内自定义材质(`ShaderMaterial`)来实现,首先来实现一个最简单的`ShaderMaterial`来看一下这个材质的组成。

```javascript
  const shader = new THREE.ShaderMaterial({
      //从程序穿到着色器里面的值，这里先不传值
        uniforms: {
        },
        //顶点着色器
         vertexShader: `
                void main()
                {
                  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
         //片段着色器
         fragmentShader: `
                  void main()
                  {
                    gl_FragColor = vec4(1.0);
                  }`,
      });
复制代码
```

1. 顶点着色器（`vertexShader `）：首先来介绍一下顶点着色器，顶点着色器是用来处理顶点数据的，本例子中的顶点着色器主要代码就一句：

```javascript
 gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
复制代码
```

先来说一下每个变量的意思

- position：模型点位数据。
- modelViewMatrix：视图矩阵，等于camera.matrixWorldInverse * object.matrixWorld，就是模型矩阵和相机矩阵（视图矩阵）的乘积。
- projectionMatrix：投影矩阵，等于camera.projectionMatrix。
- gl_Position：矩阵变换后模型点位投影到屏幕上的位置，该值与position的关系如下图。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6757d1dec7204692b1aa25d403fbb7f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

经过上述的矩阵变化，模型就会投影到裁剪坐标系然后经过一系列计算，显示到屏幕上。

1. 片段着色器 （`fragmentShader `）：片段着色器是片元的颜色,本例子中的顶点着色器如下：

```javascript
 gl_FragColor = vec4(1.0，1.0，1.0，1.0);
复制代码
```

gl_FragColor是每个片段的颜色，这里统一设置成白色` vec4(1.0，1.0，1.0，1.0)`。 然后把这个材质赋给模型

```javascript
//object.geometry是模型的geometry属性，shader是上面定义的材质
  const city = new THREE.Mesh(object.geometry, shader);
//把重新生成的模型对象添加到场景里面
  scene.add(city);
复制代码
```

这里的显示效果：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fc92c07563e461da3eaf5a2728339b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

所有的建筑模型显示白色。

## 上升线效果实现

1. 这个效果的实现需要四个值：线上升到的高度`height`、上升线的颜色`uFlowColor`、建筑模型的颜色`uCityColor`、模型点位的高度值z（这个顶点着色器里面有，需要从顶点着色器传到片段着色器中），然后把这些值通过`uniforms`传入到着色器里面去。着色器代码如下：

```javascript
   const shader = new THREE.ShaderMaterial({
        uniforms: {
          height: this.height,
         uFlowColor: {
            value: new THREE.Color("#5588aa"),
          },
          uCityColor: {
            value: new THREE.Color("#FFFFDC"),
          },
        },
        vertexShader: `
                varying vec3 vPosition;
                void main()
                {
                  vPosition = position;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
        fragmentShader: `
                  varying vec3 vPosition;
                    uniform float height;
                     uniform float uStartTime; 
                    uniform vec3 uSize;
                    uniform vec3 uFlow;
                    uniform vec3 uFlowColor;
                    uniform vec3 uCityColor;
                  void main()
                  {
                    //模型的基础颜色
                   vec3 distColor=uCityColor;
                 // 流动范围当前点z的高度加上流动线的高度
                   float topY = vPosition.z +5.0;
                if (height > vPosition.z && height < topY) {
                   // 颜色渐变 
                    distColor = uFlowColor; 
                  }
                   gl_FragColor = vec4(distColor, 0.6);
                  }`,
                    transparent: true,
      });
复制代码
```

render添加如下代码

```javascript
      this.height.value += 0.03;
      if(this.height.value>100)
      {
        this.height.value=0.0
      }
复制代码
```

首先说一下render中的代码，render是在每一次渲染中都会执行，在每一帧渲染时把height值逐渐增加，当height大于100的时候重置。

接下来是shader材质的定义，这里我们在uniforms中把需要的上升线的高度`height`,上升线的颜色`uFlowColor`，建筑模型的颜色`uCityColor`进行了传入，然后在`vertexShader`中把`fragmentShader`需要的点位属`vPosition`性通过`varying`变量实现了两个着色器直接的共用，这样上升效果需要的变量就都齐全了。

在片段着色器中首先定义模型的基本颜色`distColor`，然后定义流动颜色的位置`float topY = vPosition.z +5.0`;`vPosition.z` 是当前点位的z值加上一个宽度就是模型需要着色的部位。下一步进行筛选，筛选点位高度在 `vPosition.z-height`和` vPosition.z+0.5-height`之间的值进行着色。把这一块的颜色设置成上升片段的颜色（`uFlowColor`）.显示效果如下图：

![SDGIF_Rusult_1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1a16e2c588740cdb77d55b6d2df39a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

项目地址: [github.com/lixiaochjaj…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flixiaochjajo%2FSmartCity-Three)



# 从零开始搭建开源智慧城市项目（四）扩散扫光和颜色渐变

[![img](https://p9-passport.byteacctimg.com/img/user-avatar/5894006e106aef734beccc90facfcfe1~300x300.image)](https://juejin.cn/user/3703616627815518)

[Lixc ![lv-2](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg)](https://juejin.cn/user/3703616627815518)

2021年12月21日 15:57 · 阅读 258

关注

## 前言

上一节实现了上升线效果，这一节继续修改上一节中的`shader`，添加颜色渐变效果和扩散扫光效果。

## 思路

颜色渐变：让扩散扫光的效果中间亮，两边暗，来模拟光的效果，可通过`sin`函数模拟效果，把扫光半径计算到0-PI之间。他们的值变化如下图，`0`，`PI`最暗，`PI/2`最亮。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3283ae469d94fdb97c8122d974e1b02~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

扩散扫光：这个思路也比较简单，设置一个原点，然后第一帧模型距离这个原点`0-10`单位长度的所有的点进行发光，第二帧距离`10-20`单位长度的点进行发光，以此类推。

## 代码讲解

```javascript
   fragmentShader: `
   //求距离的公式，平方和开根号
float distanceTo(vec2 src,vec2 dst)
{
    float dx=src.x-dst.x;
    float dy=src.y-dst.y;
    float dv=dx*dx+dy*dy;
    return sqrt(dv);
}
varying vec3 vPosition;
uniform float height;
uniform vec3 uFlowColor;
uniform vec3 uCityColor;
void main()
{
    //模型的基础颜色
    vec3 distColor=uCityColor;
    //定位当前点位位置
    vec2 position2D=vec2(vPosition.x,vPosition.y);
    //求点到原点的距离
    float Len=distanceTo(position2D,vec2(0,0));
      if(Len>height*30.0&&Len<(height*30.0+130.0)){
        // 颜色渐变
        float dIndex = sin((Len - height*30.0) / 130.0 * 3.14);
        //通过上面的渐变值进行颜色混合
        distColor= mix(uFlowColor, distColor, 1.0-dIndex);
    }
    //最终颜色
    gl_FragColor=vec4(distColor,1.0);
}`,
复制代码
```

传入的值和上一节相比没有变化，主函数部分关于上升线效果的也不进行介绍了，想要了解可以看上一篇文章（[juejin.cn/post/704371…](https://juejin.cn/post/7043711598174666783)) 下面说一下添加的部分。

- 函数新添加了一个计算两点（平面点）距离的函数`distanceTo`，通过勾股定理计算两个点的距离。
- `vec2 position2D=vec2(vPosition.x,vPosition.y);`是把从顶点着色器中的点的`x`,`y`坐标进行组合，重新生成了一个平面坐标。
- `float Len=distanceTo(position2D,vec2(0,0))`是计算模型点平面坐标到原点的距离，然后把距离在`height*30.0`和`height*30.0+130.0`之间的点进行混色。其中`height*30`是原点距发光环内半径的距离，`height*30+130`是原点距发光环外半径的距离，`130.0`是发光环的内径。
- `float dIndex = sin((Len - height*30.0) / 130.0 * 3.14)`是通过`sin`函数把距离在`height*30.0`到`height*30.0+130.0`之间的值进行计算，值从`height*30.0`到`height*30.0+65.0`到`height*30.0+130.0`分别是`0.0——1.0——0.0`，实现两边值小中间值大的效果。
- `distColor= mix(uFlowColor, distColor, 1.0-dIndex)`是通过mix函数进行颜色混色，把`uFlowColor`和

`distColor`两个颜色通过`1.0： 1.0-dIndex`进行混色.实现最终效果。

## 完整代码

```javascript
 setCityMaterial(object) {
      const shader = new THREE.ShaderMaterial({
        uniforms: {
          height: this.height,
          uFlowColor: {
            value: new THREE.Color("#5588aa"),
          },
          uCityColor: {
            value: new THREE.Color("#1B3045"),
          },
        },
        vertexShader: `
                varying vec3 vPosition;
                void main()
                {
                  vPosition = position;
                  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }`,
        fragmentShader: `
float distanceTo(vec2 src,vec2 dst)
{
    float dx=src.x-dst.x;
    float dy=src.y-dst.y;
    float dv=dx*dx+dy*dy;
    return sqrt(dv);
}
varying vec3 vPosition;
uniform float height;
uniform float uStartTime;
uniform vec3 uSize;
uniform vec3 uFlowColor;
uniform vec3 uCityColor;
void main()
{
    //模型的基础颜色
    vec3 distColor=uCityColor;
    // 流动范围当前点z的高度加上流动线的高度
    float topY=vPosition.z+10.;
    if(height>vPosition.z&&height<topY){
        // 颜色渐变
            float dIndex = sin((height - vPosition.z) / 10.0 * 3.14);
            distColor = mix(uFlowColor, distColor, 1.0-dIndex);

    }
    //定位当前点位位置
    vec2 position2D=vec2(vPosition.x,vPosition.y);
    //求点到原点的距离
    float Len=distanceTo(position2D,vec2(0,0));
      if(Len>height*30.0&&Len<(height*30.0+130.0)){
        // 颜色渐变
        float dIndex = sin((Len - height*30.0) / 130.0 * 3.14);
        distColor= mix(uFlowColor, distColor, 1.0-dIndex);
    }
    gl_FragColor=vec4(distColor,1.0);
}`,
                    transparent: true,
      });

      const city = new THREE.Mesh(object.geometry, shader);
      city.position.set(
        object.position.x,
        object.position.y,
        object.position.z
      );
      scene.add(city);
      city.rotateX(-Math.PI / 2);
    },
复制代码
```

## 效果图

![SDGIF_Rusult_1.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01cfb1a9ee364a6b8b110fe78ae63f0d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?) 项目地址: [github.com/lixiaochjaj…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flixiaochjajo%2FSmartCity-Three)

# 从零开始搭建开源智慧城市项目（五）背景天空盒、扩散墙、扩散圆

[![img](https://p9-passport.byteacctimg.com/img/user-avatar/5894006e106aef734beccc90facfcfe1~300x300.image)](https://juejin.cn/user/3703616627815518)

[Lixc ![lv-2](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg)](https://juejin.cn/user/3703616627815518)

2021年12月23日 15:25 · 阅读 1033

关注

## 前言

上一节实现了颜色渐变效果和扩散扫光效果，这一节来添加背景天空盒、扩散墙、扩散圆。

## 添加天空盒思路

`three`添加天空盒有两种格式，一种是需要上下左右前后六张图来组成天空盒，一种是创建一个足够大的球，把这个球表面贴上一张图 场景在球里面组成天空球。

1. 六张图：这种方式是通关`three`的`THREE.CubeTextureLoader().load`方法，吧六张图地址数据添加到该对象里面去然后把场景的背景设置为这个对象。原理图如下所示![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6475292e0b464032a70972d15e0a17f4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97b2f6557f454e09bb19e7f43c3f6fa8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)
2. 一张图：因为`three`没有加载`hdr`天空盒的方式，可以模仿加载六张图的方式，因为加载六张图相当于创建了一个正方体，每个面贴了一张图片材质，相机在正方体内形成天空盒。那么`hdr`单张图就可以通过创建一个球体，球体表面贴图，相机在球体里面来实现（这种方式是我同事提出来的脑洞😂）。 这里推荐一个网址可以下载HDR材质（这个材质既可以当天空盒来用，也可以当环境贴图来用）[polyhaven.com/hdris](https://link.juejin.cn/?target=https%3A%2F%2Fpolyhaven.com%2Fhdris) 。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1562e4b4e444c009b0ae198732f2477~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

## 天空盒实现

我这里天空盒实现选的是第一种方式（因为数据是六张图的），代码如下

```javascript
   const textureCube = new THREE.CubeTextureLoader().load(['1.jpg', '2.jpg', '3.jpg', '4.jpg', '5.jpg', '6.jpg'],);
   scene.background = textureCube; // 作为背景贴图
复制代码
```

数据如下

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad61189ddd9f4a7db57ea841b20e3b5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

效果

![SDGIF_Rusult_1.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e86e7124d6041629c50aa295c059706~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

## 扩散圆实现思路

通过`THREE.RingGeometry`创建一个圆,然后给这个圆添加想要实现效果的贴图，然后再render循环里面每一帧都改变这个圆的大小。

## 扩散圆实现

通过创建`THREE.TextureLoader()`来进行读取图片纹理数据其中`this.img`为图片地址,创建`THREE.RingGeometry`模型，把读出来的纹理赋给`THREE.MeshBasicMaterial`材质，然后再`render`循环里面改变这个模型的缩放比例来进行扩散效果模拟。 代码如下

```javascript
/* eslint-disable */
import * as THREE from 'three';
/**
 * 波纹散射图层
 * @param  options.img 照片地址
 * @param  options.speed 流动速度
 * @param  options.scene three场景
 * @param  options.radius 圆的半径
 * @param  options.thing 圆的位置
 * @param  options.meshrings 存储圆形数据
 * @example
 */

class RunRing {
  constructor(option) {
    this.img = option.img || '';
    this.speed = option.speed / 100 || 0.01;
    this.scene = option.scene;
    this.radius = option.radius || 100;
    this.position = option.position || [0, 0, 0];
    this.meshrings = [];
    this.CreatRing();
  }
  CreatRing() {
    //创建对象读取照片纹理
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(this.img, (texture) => {
      //创建圆圈结构
      const geometry = new THREE.RingGeometry(0, this.radius, 500);
      //创建材质 把读取到的图片赋给材质
      const material2 = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        depthTest: true,
        blending: THREE.AdditiveBlending,
        map: texture,
      });
      //传入的多点的话生成多个模型
      for (let i = 0; i < this.position.length; i += 1) {
        //组合生成模型
        this.meshring = new THREE.Mesh(geometry, material2);
        //设置模型的X轴偏移量，让模型平铺再X面上
        this.meshring.rotateX(Math.PI / 2);
        //设置初始状态模型缩放比例
        this.meshring.scale.set(0.1, 0.1, 0.1);
        //设置模型位置
        this.meshring.position.set(this.position[i][0], this.position[i][1], this.position[i][2]);
        //储存模型对象，用于render改变属性和销毁对象
        this.meshrings.push(this.meshring)
        //添加到场景里面
        this.scene.add(this.meshrings[i]);

      }


    });
    //创建render，每一帧进行模型改变
    this.thing = setInterval(() => {
      //循环所有创建的模型，进行改变
      for (let i = 0; i < this.position.length; i += 1) {
        //如果模型已经创建
        if (this.meshrings[i]) {
          //当模型缩放比例小于1的时候，模型进行放大
          if (this.meshrings[i].scale.x < 1) {
            this.meshrings[i].scale.set(
              this.meshrings[i].scale.x + 0.01,
              this.meshrings[i].scale.x + 0.01,
              this.meshrings[i].scale.x + 0.01,
            );
          } else {
            //当模型比例大于1的时候，模型重置
            this.meshrings[i].scale.set(0.1, 0.1, 0.1);
          }
        }
      }

    }, 50);

  }
  delete() {
    //删除scene中对应的模型
    for (let i = 0; i < this.position.length; i += 1) {
      if (this.meshrings[i]) {
        this.scene.remove(this.meshrings[i]);
      }
    }
    if (this.thing) {
      //清除render事件
      clearInterval(this.thing);
    }
  }
}
export default RunRing;
复制代码
```

数据格式

```javascript
 {
        img: "clice.png",
        scene: scene,
        speed: 1,
        radius: 400,
        position: [
          [400, 30, 400],
          [100, 30, 1200],
        ],
      }
复制代码
```

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8c509be49684bb89b3048947aa2689e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?) 效果图

![SDGIF_Rusult_1.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd34ca5bab8b407f81a5c11d05f90b4a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

## 扩散墙实现思路

扩散墙和上一节一样 是通过`ShaderMaterial`来实现的，要实现的效果是墙面随着高度增加透明度也增加，所以模型点位的透明度和高度呈反比。模型的扩散效果是把模型点位的位置通过mod函数来进行取余运算（%），把计算结果限制再0-1之间。

## 扩散墙实现

```javascript
/* eslint-disable */
import * as THREE from "three";
/**
 * 波动墙
 * @param  options.scene three场景
 * @param  options.radius 中心
 * @param  options.height 墙高度
 * @param  options.opacity 墙透明度
 * @param  options.color 墙颜色
 * @example
 */

class Wall {
  constructor(option) {
    this.scene = option.scene;
    this.radius = option.radius || 420;
    this.height = option.height || 120;
    this.opacity = option.opacity || 0.5;
    this.color = option.color || "#efad35";
    this.speed = option.speed || 0.5;
    this.mesh = ""; //生成的模型数据
    this.CreatRing();
  }
  CreatRing() {
    const vertexShader = `
uniform vec3 u_color;

uniform float time;
uniform float u_height;
 
varying float v_opacity;

void main() {
//模型点位置乘以一个0.0-1.0的系数，来模拟扩散效果。
    vec3 vPosition = position * mod(time/20.0, 1.0);
//模型的透明度和模型的高度呈反比
    v_opacity =1.0- position.y / u_height;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);
}
`;
    const fragmentShader = ` 
uniform vec3 u_color;
uniform float u_opacity;
 
varying float v_opacity;

void main() { 
    //u_color是颜色 v_opacity * u_opacity是高度所产生的透明效果和模型传入的透明度的乘积。
    gl_FragColor = vec4(u_color, v_opacity * u_opacity);
}
`;
//获取参数
    const { radius, height, opacity, color, speed, renderOrder } = this;
//生成模型结构
    const geometry = new THREE.CylinderGeometry(
      radius,
      radius,
      height,
      32,
      1,
      true
    );
    //模型位置设置
    geometry.translate(0, height / 2, 0);
    //自定义模型材质
    const material = new THREE.ShaderMaterial({
      uniforms: {
        u_height: {
          value: height,
        },
        u_opacity: {
          value: opacity,
        },
        u_color: {
          value: new THREE.Color(color),
        },
        time: {
          value: 0,
        },
      },
      transparent: true,
      depthWrite: false,
      depthTest: false,
      side: THREE.DoubleSide,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
    });
    //组合材质和结构生成对象
    const mesh = new THREE.Mesh(geometry, material);
    //设置模型遮挡，把这个模型放到最前面防止遮挡
    mesh.renderOrder = renderOrder || 1;
    this.mesh = mesh;
  }
}

export default Wall;

复制代码
```

效果图

![SDGIF_Rusult_1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7aeef256bafc44e7a9f24d2dc1b061aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

项目地址: [github.com/lixiaochjaj…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flixiaochjajo%2FSmartCity-Three)

# 从零开始搭建开源智慧城市项目（六）飞线，飞点。

[![img](https://p9-passport.byteacctimg.com/img/user-avatar/5894006e106aef734beccc90facfcfe1~300x300.image)](https://juejin.cn/user/3703616627815518)

[Lixc ![lv-2](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg)](https://juejin.cn/user/3703616627815518)

2021年12月28日 14:17 · 阅读 259

关注

## 前言

上一节实现了天空盒、扩散墙、扩散圆，这一节来添加飞线，飞点。

## 思路

主要思路是通过两个点和高度创建贝塞尔曲线，然后把该曲线的点构造成`MeshLine`（这个插件可以生成有宽度的线）,然后把想要效果的图贴到线上。

- 飞点：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a47aae6d4f461abdc51a64f2af0f73~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/697e4a765e3d448e91c46bdc80e52ae3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

- 飞线

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4aaad45e6f8a40e7b249b1309fea84be~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad639aecd21c4748bfea5ebdd41a799e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

这里用到了别人写的`MeshLine`插件（[github.com/spite/THREE…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fspite%2FTHREE.MeshLine) ），对这个代码做了一点点修改，可进行模型材质的uv移动（`THREE`高版本有问题，我这边用的是127版本没有问题）。 ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d3d1959535e450294a2ed3cb8400158~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?) 这个修改是借鉴的`deckgl`（[deck.gl/](https://link.juejin.cn/?target=https%3A%2F%2Fdeck.gl%2F) ）具体的修改就是把`UV`偏移量传进去实现偏移。

## 代码

```javascript
import * as THREE from 'three';
import { Geometry } from 'three/examples/jsm/deprecated/Geometry';
import { MeshLine, MeshLineMaterial } from './THREE.MeshLine';

THREE.Geometry = Geometry;
/**
 * 波纹散射图层
 * @param  options.img 照片地址
 * @param  options.lineWidth 线宽度
 * @param  options.side 贴图样式
 * @param  options.camera 相机
 * @param  options.height 高度
 * @param  options.v0 点一
 * @param  options.v1 点二
 * @param  options.speed 流动速度
 * @param  options.el 节目场景元素
 * @param  options.type 线类型分run和top
 * @param  options.maxheight 当类型为top时最高上升高度
 * @param  options.line 存储线
 * @param  options.thing 存储setInterval事件
 * @example
 */
class RunLine {
  constructor(option) {
    this.img = option.img || '';
    this.lineWidth = option.lineWidth || 1;
    this.side = option.side || THREE.FrontSide;
    this.camera = option.camera || '';
    this.height = option.height || 100;
    this.v0 = option.v0 || new THREE.Vector3(0, 0, 0);
    this.v1 = option.v1 || new THREE.Vector3(0, 0, 0);
    this.speed = option.speed / 100 || 0.01;
    this.el = option.el || '';
    this.scene = option.scene || '';
    this.type = option.type || 'run';
    this.maxheight = option.maxheight || 300;
    this.line = '';
    this.thing = '';
    this.creatline();
  }

  creatline() {
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(this.img, (texture) => {
      this.texture = texture;
      this.texture.anisotropy = 16;
      this.texture.wrapS = THREE.RepeatWrapping; // 每个都重复
      this.texture.wrapT = THREE.RepeatWrapping;
      const resolution = new THREE.Vector2(this.el.offsetWidth, this.el.offsetHeight);
      const material1 = new MeshLineMaterial({
        color: '',
        map: this.texture,
        useMap: true,
        lineWidth: this.lineWidth,
        resolution,
        dashArray: 0, // 破折号之间的长度和间距。(0 -无破折号)
        dashRatio: 0.7, // 定义可见和不可见之间的比率(0 -更可见，1 -更不可见)。
        dashOffset: 1,
        transparent: true,
        sizeAttenuation: 1, // 使线宽不变，不管距离(1个单位是屏幕上的1px)(0 -衰减，1 -不衰减)
        side: THREE.FrontSide,
        depthTest: false,
        blending: THREE.AdditiveBlending,
        near: this.camera.near,
        far: this.camera.far,
      });
      this.line = this.createAnimateLine({
        kind: 'sphere', // 默认不填 为普通 ; 如为sphere,则表示球面建点
        type: 'line', // 默认不填 为MeshLine ; 如为pipe,则表示管道线
        sphereHeightPointsArgs: [this.v0, this.v1],
        material: material1,
        number: 50,
        radius: 3, // 默认
      });
      if (this.type === 'run') {
        this.line1 = this.createAnimateLine({
          kind: 'sphere', // 默认不填 为普通 ; 如为sphere,则表示球面建点
          type: 'line', // 默认不填 为MeshLine ; 如为pipe,则表示管道线
          sphereHeightPointsArgs: [this.v0, this.v1],
          material: material1,
          number: 50,
          radius: 3, // 默认
        });
      }

      this.scene.add(this.line);
      this.scene.add(this.line1);
      const { speed } = this;
      if (this.type === 'run') {
        this.thing = setInterval(() => {
          this.line.material.uniforms.offset.value.x -= speed;
          this.line1.material.uniforms.offset.value.x -= speed;
        }, 30);
      } else if (this.type === 'top') {
        this.thing = setInterval(() => {
          if (this.line.position.y < this.maxheight) {
            this.line.position.y += this.speed * 100;
          } else {
            this.line.position.y = 0;
          }
        }, 30);
      }
    });
  }

  createAnimateLine(option) {
    let curve;

    if (option.kind === 'sphere') {
      // 由两点之间连线成贝塞尔曲线
      const { sphereHeightPointsArgs } = option;
      const vX = (sphereHeightPointsArgs[1].x + sphereHeightPointsArgs[0].x) / 2;
      const vZ = (sphereHeightPointsArgs[1].z + sphereHeightPointsArgs[0].z) / 2;
      if (this.type === 'run') {
        curve = new THREE.CubicBezierCurve3(
          sphereHeightPointsArgs[0],
          new THREE.Vector3(vX, this.height, vZ),
          new THREE.Vector3(vX, this.height, vZ),
          sphereHeightPointsArgs[1],
        );
      } else {
        curve = new THREE.CubicBezierCurve3(
          sphereHeightPointsArgs[0],
          new THREE.Vector3(vX, this.height, vZ),
          new THREE.Vector3(vX, this.height, vZ),
          sphereHeightPointsArgs[1],
        );
      }
    }

    if (option.type === 'line') {
      const geo = new THREE.Geometry();
      geo.setFromPoints(curve.getPoints(100));

      // const geo = new Geometry();
      // geo.vertices = option.sphereHeightPointsArgs;
      const meshLine = new MeshLine();
      meshLine.setGeometry(geo);
      return new THREE.Mesh(meshLine.geometry, option.material);
    } // 使用 meshLine

    return '';
  }

  delete() {
    if (this.line) {
      this.scene.remove(this.line);
      this.scene.remove(this.line1);
    }
    if (this.thing) {
      clearInterval(this.thing);
    }
  }
}

export default RunLine;
复制代码
```

调用代码

```
 this.runline5 = new RunLine({
        img: "n.png",
        camera: camera,
        height: 140,
        v0: new THREE.Vector3(614, 18, 130),
        v1: new THREE.Vector3(-17.5, 111.5, -23),
        el: document.getElementById("scene"),
        scene: scene,
        speed: 1,
        lineWidth: 12,
        type: "run",
      });
复制代码
```

## 效果图

![SDGIF_Rusult_1.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da32bf035b104f7a8576e18e0a79c297~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

项目地址[github.com/lixiaochjaj…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flixiaochjajo%2FSmartCity-Three)

# 从零开始搭建开源智慧城市项目（七）场景导入到地图中。

[![img](https://p9-passport.byteacctimg.com/img/user-avatar/5894006e106aef734beccc90facfcfe1~300x300.image)](https://juejin.cn/user/3703616627815518)

[Lixc ![lv-2](https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg)](https://juejin.cn/user/3703616627815518)

2022年03月14日 16:00 · 阅读 135

关注

## 前言

上一节通过`MeshLine`添加了飞线飞点 这一节把整个场景导入到mapbox中。

## 思路

主要思路就是`mapbox`的`customLayer`图层，可以把`three`的3d场景通过场景和控制器的重叠进行导入，这样本质上mapbox和three还是两个互不干扰的场景。

## 实现步骤

1. 初始化地图场景
2. 当地图加载完成后，初始化custom图层（参考[docs.mapbox.com/mapbox-gl-j…](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.mapbox.com%2Fmapbox-gl-js%2Fexample%2Fadd-3d-model%2F%3Fsize%3Dn_10_n%EF%BC%89)
3. 设置render中模型位置和相机的相关变化（涉及到坐标转换这个方面准备专门写一章来讲一下自己的理解）
4. 其他的three相关内容参考以前的章节

## 代码

```javascript
  initmap() {
      mapboxgl.accessToken =
        "??"; //这里请换成自己的token
      map = new mapboxgl.Map({
        container: "map", // container id 绑定的组件的id
        style: "mapbox://styles/mapbox/streets-v11", //地图样式，可以使用官网预定义的样式,也可以自定义
        center: [121.47, 31.23], // 初始坐标系
        zoom: 15, // starting zoom 地图初始的拉伸比例
        pitch: 60, //地图的角度，不写默认是0，取值是0-60度，一般在3D中使用
        bearing: -17.6, //地图的初始方向，值是北的逆时针度数，默认是0，即是正北
        antialias: true, //抗锯齿，通过false关闭提升性能
      });
    }
    setCustomLayer() {
      const customLayer = {
        id: "3d-model",
        type: "custom",
        renderingMode: "3d",
        onAdd: this.initThree,
        // eslint-disable-next-line no-unused-vars
        render: this.threeRender,
      };
      return customLayer;
    },
       initThree(map, gl) {
      //创建场景
      scene = new THREE.Scene();
      /**
       * 透视投影相机设置
       */
      const width = window.innerWidth; // 窗口宽度
      const height = window.innerHeight; // 窗口高度

      /** 透视投影相机对象 */
      camera = new THREE.PerspectiveCamera(60, width / height, 1, 700);
      camera.position.set(600, 900, 600); // 树上面观察
      camera.lookAt(scene.position); // 设置相机方向(指向的场景对象)
      // 创建渲染器对象
      //   const container = document.getElementById("scene");
      renderer = new THREE.WebGLRenderer({
        canvas: map.getCanvas(),
        context: gl,
        antialias: true,
      });
      //   container.appendChild(renderer.domElement); // body元素中插入canvas对象

      //创建点光源和环境光源
      const point = new THREE.PointLight(0xffffff);
      point.position.set(600, 900, 600); // 点光源位置
      scene.add(point); // 点光源添加到场景中
      // 环境光
      const ambient = new THREE.AmbientLight(0x404040, 1);
      scene.add(ambient);
      renderer.autoClear = false;
      //   pickingScene = new THREE.Scene(); //离屏渲染
      //   pickingTexture = new THREE.WebGLRenderTarget(1, 1); //离屏渲染
    },
    threeRender(gl, matrix) {
      const modelOrigin = [121.47, 31.23];
      const modelAltitude = 770;
      const modelRotate = [Math.PI / 4, 0, 0];
      const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
        modelOrigin,
        modelAltitude
      );
      const modelTransform = {
        translateX: modelAsMercatorCoordinate.x,
        translateY: modelAsMercatorCoordinate.y,
        translateZ: modelAsMercatorCoordinate.z,
        rotateX: modelRotate[0],
        rotateY: modelRotate[1],
        rotateZ: modelRotate[2],
        scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits(),
      };
      const rotationX = new THREE.Matrix4().makeRotationAxis(
        new THREE.Vector3(1, 0, 0),
        modelTransform.rotateX
      );
      const rotationY = new THREE.Matrix4().makeRotationAxis(
        new THREE.Vector3(0, 1, 0),
        modelTransform.rotateY
      );
      const rotationZ = new THREE.Matrix4().makeRotationAxis(
        new THREE.Vector3(0, 0, 1),
        modelTransform.rotateZ
      );

      const m = new THREE.Matrix4().fromArray(matrix);
      const l = new THREE.Matrix4()
        .makeTranslation(
          modelTransform.translateX,
          modelTransform.translateY,
          modelTransform.translateZ
        )
        .scale(
          new THREE.Vector3(
            modelTransform.scale,
            -modelTransform.scale,
            modelTransform.scale
          )
        )
        .multiply(rotationX)
        .multiply(rotationY)
        .multiply(rotationZ);

      camera.projectionMatrix = m.multiply(l);
      this.cityanimate();
      renderer.resetState();
      renderer.render(scene, camera);
      map.triggerRepaint();
    },
复制代码
```

调用代码

```
this.initmap();
    map.on("style.load", () => {
      let customLayer = this.setCustomLayer();
      map.addLayer(customLayer, "waterway-label");
      this.addGLTF();
      this.creatWall();
      this.creatRunLine();
    });
复制代码
```

## 效果图

![SDGIF_Rusult_1.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/328485d3f6f5473ab45263d29cbf042c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?)

项目地址[github.com/lixiaochjaj…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Flixiaochjajo%2FSmartCity-Three)